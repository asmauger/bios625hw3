% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pca1.R
\name{pca}
\alias{pca}
\title{Principal Components Analysis}
\usage{
pca(x, formula = NULL, data = NULL, subset = NULL, scale = T, retx = T)
}
\arguments{
\item{x}{a numeric matrix or data frame containing data for the PCA.}

\item{formula}{optional; instead of \code{x}, specify a formula containing numeric variables from \code{data}. Do not specify a response variable.}

\item{data}{a matrix or data frame containing the variables specified in \code{formula}. Only required if \code{formula} is used.}

\item{subset}{an optional vector containing indices for rows of \code{x} or of \code{data} to be used for the PCA.}

\item{scale}{a logical value indicating whether the variables should be mean-centered and scaled to unit variance.}

\item{retx}{a logical value indicating whether the rotated matrix should be returned.}
}
\value{
Returns a list of class \code{pca} containing the following elements: \describe{
\item{center}{the means of the input variables used for centering if \code{scale=T}.}
\item{scale}{the standard deviations of the variables used for scaling if \code{scale=T}.}
\item{sdev}{the standard deviations of the principal components.}
\item{rotation}{a matrix of the principal components. More specifically, each column represents an eigenvector of the covariance matrix of the input data.}
\item{x}{a matrix containing the rotated data if \code{retx=T}. That is, the scaled data multiplied by \code{rotation}.}
\item{summary}{a matrix containing \code{sdev}, the proportion of variance associated with each PC, and the cumulative proportion of variance associated with each PC. Can be accessed with \code{summary()}.}
}
}
\description{
Performs a principal component analysis on input data and returns the principal components and related quantities in an object of class \code{pca}.
}
\examples{
data(iris)
# Note: cannot include non-numeric variables.
p1 = pca(iris[, -5]) # Input matrix method.
summary(p1)
p2 = pca(~Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data=iris) # Formula method.
summary(p2)
all.equal(summary(p1), summary(p2)) # both methods yield same results
# Scaling is recommended, but can be skipped.
p3 = pca(~Sepal.Length + Sepal.Width, data=iris, subset=c(1,50), scale=FALSE)
summary(p3)
}
